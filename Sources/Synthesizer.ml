(* Author: Samuele Giraudo
 * Creation: (jul. 2015), apr. 2020
 * Modifications: apr. 2020, may 2020, jul. 2020, aug. 2020
 *)

(* A timbre is an association list associating with some integers i the weights of the i-th
 * harmonics between 0.0 and 1.0. These weights have to be different from 0.0. If an integer
 * i is not is this association list, the weight of the i-th harmonic is 0.0. The
 * fundamental harmonics is the 1-st one. *)
type timbre = (int * float) list

(* A synthesizer is a template for a sound, providing its timbre and its shape. The sounds
 * it generates can have different pitches and different durations. *)
type synthesizer = {
    (* The timbre of the sounds generated by the synthesizer.*)
    timbre : timbre;

    (* The maximal duration in ms of the sound. The loudness decreases linearly from 1.0 to
     * 0.0 in this duration. *)
    max_duration : int;

    (* The duration in ms between the start and the sustain phase of the sound, where the
     * loudness increases linearly. *)
    open_duration : int;

    (* The duration in ms between the sustain phase of the sound and the end, where the
     * loudness decreases linearly. *)
    close_duration : int
}

(* An exception for strings specifying synthesizers which are in bad format. *)
exception FormatError

(* An exception for data specifying synthesizers which have wrong values. *)
exception ValueError

(* The minimal nonzero allowed value for the weights in timbres. *)
let min_weight =
    2.0 ** (-. 16.0)

let is_valid_timbre t =
    List.length (t |> List.map fst |> List.sort_uniq compare) = List.length t
        && t |> List.map fst |> List.for_all (fun i -> i >= 1)
        && t |> List.map snd |> List.for_all (fun c -> min_weight <= c && c <= 1.0)

(* Returns the timbre obtained from the timbre t by scaling each of its weights by the
 * coefficient c. *)
let scale_timbre v t =
    assert (0.0 <= v);
    t |> List.map (fun (i, c) -> (i, v *. c)) |> List.filter (fun (_, c) -> min_weight <= c)

(* Returns a string representation of the timbre t. *)
let timbre_to_string t =
    assert (is_valid_timbre t);
    t |> List.map (fun (i, c) -> Printf.sprintf "%d: %.4f" i c) |> String.concat ", "

(* Tests if synth is a synthesizer. *)
let is_valid synth =
    synth.max_duration >= 0 && synth.open_duration >= 0 && synth.close_duration >= 0
        && is_valid_timbre synth.timbre

(* Returns the synthesizer with the specified attributes. *)
let construct timbre max_duration open_duration close_duration =
    let synth = {
        timbre = timbre;
        max_duration = max_duration;
        open_duration = open_duration;
        close_duration = close_duration} in
    if not (is_valid synth) then
        raise ValueError;
    synth

(* Returns a string representation of the synthesizer synth. *)
let to_string synth =
    assert (is_valid synth);
    Printf.sprintf
        "Timbre: %s\nMax duration: %d ms\nOpen duration: %d ms\nClose duration: %d ms"
        (timbre_to_string synth.timbre) synth.max_duration synth.open_duration
        synth.close_duration

(* Returns the sound obtained by stacking the sinusoidal sounds with the coefficients
 * specified by the timbre timbre. The returned sound has freq as frequency in Hz and
 * duration as duration in ms. *)
let stacked_harmonics timbre freq duration =
    assert (is_valid_timbre timbre);
    assert (0.0 < freq);
    assert (0 <= duration);
    let sounds = timbre |> List.map
        (fun (i, c) ->
            let f = freq *. (float_of_int i) in
            Sound.scale c (Sound.sinusoidal f duration)) in
    Sound.add_list sounds

(* Returns the shape specified by the durations max_duration, open_duration and
 * close_duration in ms, w.r.t. a sound having duration as duration in ms. *)
let shape_durations max_duration open_duration close_duration duration =
    assert (duration >= 1);
    assert (max_duration >= 1);
    assert (open_duration >= 1);
    assert (close_duration >= 1);
    let max_proportion = (float_of_int max_duration) /. (float_of_int duration)
    and open_proportion = (float_of_int open_duration) /. (float_of_int duration)
    and close_proportion = (float_of_int close_duration) /. (float_of_int duration) in
    let shape_max t =
        if 0.0 <= t && t <= max_proportion then
            (max_proportion -. t) /. max_proportion
        else
            0.0
    in
    let shape_open t =
        if 0.0 <= t && t <= open_proportion then
            t /. open_proportion
        else
            1.0
    in
    let shape_close t =
        if 1.0 -. close_proportion <= t && t <= 1.0 then
            (1.0 -. t) /. close_proportion
        else
            1.0
    in
    Sound.compose_shapes shape_max (Sound.compose_shapes shape_open shape_close)

(* Returns the sound generated by the synthesizer synth having freq as frequency in Hz and
 * duration as duration in ms. *)
let generate_sound synth freq duration =
    assert (is_valid synth);
    assert (0.0 < freq);
    assert (0 <= duration);
    let s = stacked_harmonics synth.timbre freq duration in
    let sh = shape_durations
        synth.max_duration synth.open_duration synth.close_duration duration in
    Sound.apply_shape s sh

(* Returns the sound generated by the synthesizer synth corresponding with the note note and
 * having duration as duration in ms. *)
let generate_sound_note synth note duration =
    assert (is_valid synth);
    assert (Note.is_valid note);
    assert (0 <= duration);
    generate_sound synth (Note.frequency note) duration

(* Returns the timbre which is the geometric progression of the value v. This value has to
 * be between 0.0 and 1.0 (strictly). *)
let geometric_timbre v =
    assert (0.0 < v && v < 1.0);
    let rec aux i =
        let coeff = v ** (float_of_int (i - 1)) in
        if coeff < min_weight then
            []
        else
            (i, coeff) :: aux (i + 1)
    in
    aux 1

(* Returns the timbre which is the arithmetic reverse progression of the value v. This value
 * has to be between 0.0 and 1.0. *)
let arithmetic_timbre v =
    assert (0.0 <= v && v < 1.0);
    let v' = 1.0 -. v in
    let rec aux i =
        let coeff = 1.0 -. (float_of_int (i - 1)) *. v' in
        if coeff < min_weight then
            []
        else
            (i, coeff) :: aux (i + 1)
    in
    aux 1

(* Returns the timber made of harmonics corresponding with octaves and with 1.0 as weight.
 * The number of such harmonics is nb_octaves. *)
let octaves_timbre nb_octaves =
   assert (1 <= nb_octaves);
    List.init nb_octaves (fun i ->  (1 lsl i, 1.0))

(* Returns the timber wherein the first nb_harmonics have 1.0 as weight and the other ones
 * have 0.0. *)
let full_timbre nb_harmonics =
    assert (1 <= nb_harmonics);
    List.init nb_harmonics (fun i -> (i + 1, 1.0))

(* Returns the timbre obtained from the integer list seq. The i-th harmonics admits as
 * weight the inverse of the i-th term of seq. *)
let sequence_timbre seq =
    assert (seq |> List.for_all (fun j -> 1 <= j));
    let len = List.length seq in
    let inv_seq = seq |> List.map (fun j -> 1.0 /. (float_of_int j)) in
    List.combine (List.init len (fun i -> i + 1)) inv_seq


(* The test function of the module. *)
let test () =
    print_string "Synthesizer\n";

    true

