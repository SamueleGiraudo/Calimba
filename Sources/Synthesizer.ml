(* Author: Samuele Giraudo
 * Creation: (jul. 2015), apr. 2020
 * Modifications: apr. 2020, may 2020, jul. 2020, aug. 2020, dec. 2020
 *)

(* A synthesizer is a template for a sound, providing its timbre and its shape. The sounds
 * it generates can have different pitches and different durations. *)
type synthesizer = {
    (* The timbre of the sounds generated by the synthesizer.*)
    timbre : Timbre.timbre;

    (* The maximal duration in ms of the sound. The loudness decreases linearly from 1.0 to
     * 0.0 in this duration. *)
    max_duration : int;

    (* The duration in ms between the start and the sustain phase of the sound, where the
     * loudness increases linearly. *)
    open_duration : int;

    (* The duration in ms between the sustain phase of the sound and the end, where the
     * loudness decreases linearly. *)
    close_duration : int
}

(* Returns the synthesizer with the specified attributes. *)
let construct timbre max_duration open_duration close_duration =
    assert (max_duration >= 0);
    assert (open_duration >= 0);
    assert (close_duration >= 0);
    {timbre = timbre;
     max_duration = max_duration;
     open_duration = open_duration;
     close_duration = close_duration}

(* Returns a string representation of the synthesizer synth. *)
let to_string synth =
    Printf.sprintf
        "[timbre: %s; max duration: %d ms; open duration: %d ms; close duration: %d ms]"
        (Timbre.to_string synth.timbre) synth.max_duration synth.open_duration
        synth.close_duration

(* Returns the sound obtained by stacking the sinusoidal sounds with the coefficients
 * specified by the timbre timbre. The returned sound has freq as frequency in Hz and
 * duration as duration in ms. *)
let stacked_harmonics timbre freq duration =
    assert (0.0 < freq);
    assert (0 <= duration);
    let sounds = List.init (Timbre.nb_weights timbre) (fun i -> i + 1) |> List.map
        (fun i ->
            let f = freq *. (float_of_int i) in
            Sound.scale (Timbre.weight timbre i) (Sound.sinusoidal f duration)) in
    Sound.add_list sounds

(* Returns the sound generated by the synthesizer synth having freq as frequency in Hz and
 * duration as duration in ms. *)
let generate_sound synth freq duration =
    assert (0.0 < freq);
    assert (0 <= duration);
    let s = stacked_harmonics synth.timbre freq duration in
    let sh = Shape.trapezoid
        synth.max_duration synth.open_duration synth.close_duration duration in
    Sound.apply_shape s sh

(* Returns the sound generated by the synthesizer synth corresponding with the note note and
 * having duration as duration in ms. *)
let generate_sound_note synth note duration =
    assert (0 <= duration);
    generate_sound synth (Note.frequency note) duration

